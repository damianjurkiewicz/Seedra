<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_Machine" Id="{d5c1a520-7f34-4388-b108-926928c14741}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Machine EXTENDS FB_PackML_BaseModule // IMPLEMENTS I_ControlsProductionRate
VAR
    // Sub Modules
    GantryXY   : FB_GantryXY  := (Name := 'Gantry', LogStateChanges := TRUE);
    SpindleZ   : FB_SpindleZ    := (Name := 'Spindle', LogStateChanges := TRUE);

    // Components

    //Initial List of Components
    ipComponents_Init : ARRAY[1..Parameters_PackML_Base.MAX_NO_OF_COMPONENTS] OF I_ComponentBase := [];

    //Alarms for this module
    MachineAlarms : ARRAY[1..MACHINE_ALARM_COUNT] OF FB_TcAlarm;

	//Simulation variables
	LowAirInput :BOOL;
	EstopInput :BOOL;

END_VAR

VAR CONSTANT
    //Alarm count constant
    MACHINE_ALARM_COUNT : INT := 6;
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="MachineStates" Id="{7e41413f-6ba1-0380-01c0-e5e34869e80f}" />
    <Method Name="CreateEvents" Id="{3ef7297b-dc6e-4a47-8d8e-332da0b8eab2}">
      <Declaration><![CDATA[METHOD PROTECTED CreateEvents
VAR_INPUT
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Add your event creation here
F_CreateAllEventsInClass(Alarms     := MachineAlarms,
                         ClassSize  := SIZEOF(TC_Events.Seedra),
                         pInitEvent := ADR(TC_EVENTS.Seedra.InitReferenceEvent),
                         Prefix     := Name);
// Super call to base
SUPER^.CreateEvents();]]></ST>
      </Implementation>
    </Method>
    <Method Name="CyclicLogic" Id="{3a2f2751-120e-49d4-84e7-dd5883d6841e}">
      <Declaration><![CDATA[METHOD CyclicLogic
VAR_INPUT
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT _InitComplete THEN
    _InitComplete := Initialize();
    RETURN;
END_IF

SUPER^.CyclicLogic();


]]></ST>
      </Implementation>
    </Method>
    <Method Name="Execute" Id="{8d9cf37d-4012-0acb-01e4-be86aea7490d}" FolderPath="MachineStates\">
      <Declaration><![CDATA[METHOD PROTECTED FINAL Execute
VAR
	Delay: TON;
	Count : INT :=0;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE _CurrentMode OF
//===================PRODUCTION MODE=======================
	E_PMLUnitMode.ePMLUnitMode_Production:
	CASE SequenceState OF
		0:
			Delay(IN:=TRUE, PT:=T#5S);
			IF NOT(Delay.Q) THEN
				SequenceState := SequenceState + 10;
			END_IF
			
		10:	//There is an idea to Activate EM slowly, by Starting them from the Idle state
			Delay(IN:=FALSE);   
//			FB_GantryXY.ChangeState(E_PMLCommand.ePMLCommand_Start);
//			FB_SpindleZ.ChangeState(E_PMLCommand.ePMLCommand_Start);
			SUPER^.Starting();

	END_CASE

//===================MAINTENANCE MODE=======================
//Go to the most convinient position for the cleaning 
    E_PMLUnitMode.ePMLUnitMode_Maintenance:
        ;


//===================MANUAL MODE=======================
//Allow individual Control of each Module
	E_PMLUnitMode.ePMLUnitMode_Manual:
	
		;
END_CASE
	

	]]></ST>
      </Implementation>
    </Method>
    <Method Name="HMIPermissions" Id="{01f1aea6-e802-48f8-abd4-50a2a3d31fba}">
      <Declaration><![CDATA[METHOD PROTECTED HMIPermissions
VAR_INPUT
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//General Mode Based Monitoring and handling of HMI control
CASE _CurrentMode OF
   
 E_PMLUnitMode.ePMLUnitMode_Production:
        CASE _CurrentState OF
            E_PMLState.ePMLState_Stopped:
				AllowHMIControl(ThisModuleOnly := FALSE);
            E_PMLState.ePMLState_Idle:
				AllowHMIControl(ThisModuleOnly := FALSE);
            E_PMLState.ePMLState_Suspended:
         		AllowHMIControl(ThisModuleOnly := FALSE);
            E_PMLState.ePMLState_Execute:
            	AllowHMIControl(ThisModuleOnly := FALSE); 
            E_PMLState.ePMLState_Aborted:
                AllowHMIControl(ThisModuleOnly := FALSE); 
            E_PMLState.ePMLState_Held:
                AllowHMIControl(ThisModuleOnly := FALSE); 
            E_PMLState.ePMLState_Complete:
          		AllowHMIControl(ThisModuleOnly := FALSE); 
        END_CASE
		
    E_PMLUnitMode.ePMLUnitMode_Manual:
        AllowHMIControl(ThisModuleOnly := FALSE); 
	E_PMLUnitMode.ePMLUnitMode_Maintenance:
        AllowHMIControl(ThisModuleOnly := FALSE); 
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="Idle" Id="{b8a07900-266f-0b30-359e-8e8df7b36472}" FolderPath="MachineStates\">
      <Declaration><![CDATA[//! @summary This method contains code which will execute when this PackML module is in the <b>Idle</b> state
METHOD PROTECTED Idle
	VAR
		Delay :TON;
	END_VAR
(*! <description> <b>The base implementation of this method is empty. User must override this method to provide functionality.</b>
<table> 
	<tr>
		<th> Previous State </th>
		<th> Transition In </th>
		<th> Transition Out </th>
		<th> Next State  </th> 
	</tr>
	<tr>
		<td> Resetting </td>
		<td> State Complete <i>(Resetting)</i></td> 
		<td> Start Command </td>
		<td> Starting </td> 
	</tr>
</table>
This method is called as required by <c>StateControl()</c>
</description> 

*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE _CurrentMode OF
//==========================PRODUCTION MODE=======================
	E_PMLUnitMode.ePMLUnitMode_Production:
	CASE SequenceState OF	
		0:
			Delay(IN:=TRUE, PT:=T#5S);
			Trace('Wait before Idle');

			
		10:	//Started
			Trace('Idle');

	END_CASE
	E_PMLUnitMode.ePMLUnitMode_Maintenance, E_PMLUnitMode.ePMLUnitMode_Manual:
	
	SUPER^.Idle();
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="Initialize" Id="{c8e5bfb3-7a5f-4315-8e43-29ab3e5bd8c9}">
      <Declaration><![CDATA[METHOD PROTECTED Initialize : BOOL
VAR
    i : UDINT; //Generic iteration value
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Initialize := FALSE;
CASE DescendantSequenceState OF
    0:
		RegisterSubmodule(GantryXY);
		RegisterSubmodule(SpindleZ);
		
        _LogModeChanges         := FALSE;
        _LogStateChanges        := FALSE;
        DescendantSequenceState := DescendantSequenceState + 10;
    10:
        //Setup Custom modes here

        (*CustomModes(eMode                          :=,
                    sName                          :=,
                    bDisableClearing               :=,
                    bDisableStarting               :=,
                    bDisableSuspended              :=,
                    bDisableStopping               :=,
                    bDisableAborting               :=,
                    bDisableHolding                :=,
                    bDisableHeld                   :=,
                    bDisableUnholding              :=,
                    bDisableSuspending             :=,
                    bDisableUnsuspending           :=,
                    bDisableResetting              :=,
                    bDisableIdle                   :=,
                    bDisableCompleting             :=,
                    bDisableComplete               :=,
                    bEnableUnitModeChangeStopped   :=,
                    bEnableUnitModeChangeIdle      :=,
                    bEnableUnitModeChangeSuspended :=,
                    bEnableUnitModeChangeExecute   :=,
                    bEnableUnitModeChangeAborted   :=,
                    bEnableUnitModeChangeHeld      :=,
                    bEnableUnitModeChangeComplete  :=,
                    bError                         =>,
                    nErrorId                       =>);*)
        DescendantSequenceState := DescendantSequenceState + 10;
    20:
        //Copy Mode names
        FOR i := 1 TO 3 DO
            ModeNames[i] := F_UnitModeToString(UDINT_TO_DINT(i));
        END_FOR

        DescendantSequenceState := DescendantSequenceState + 10;
    30:
        // Initialize Recipes 

        DescendantSequenceState := DescendantSequenceState + 10;
    40:
        //Call the Super
        IF SUPER^.Initialize() THEN
            DescendantSequenceState := DescendantSequenceState + 10;
        END_IF
    50:
        Initialize := TRUE;
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="Starting" Id="{085d02f0-516d-061c-276a-6d5cef6a38a4}" FolderPath="MachineStates\">
      <Declaration><![CDATA[//! @summary This method contains code which will execute when this PackML module is in the <b>Starting</b> state
METHOD PROTECTED Starting
VAR
	i				: UDINT;
	SubModulesReady : BOOL := TRUE;
	Delay : TON;
END_VAR

(*! <description><b></b><table> 
	<tr>
		<th> Previous State </th>
		<th> Transition In </th>
		<th> Transition Out </th>
		<th> Next State  </th> 
	</tr>
	<tr>
		<td> Idle </td>
		<td> Start Command </td> 
		<td> State Complete </td>
		<td> Execute </td> 
	</tr>
</table>
This method is called as required by <c>StateControl()</c>
</description> 

*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE _CurrentMode OF
//===================PRODUCTION MODE=======================
E_PMLUnitMode.ePMLUnitMode_Production:
CASE SequenceState OF
		0:
			Trace('Wait for Starting');
			Delay(IN:=TRUE, PT:=T#5S);
			IF NOT(Delay.Q) THEN
				SequenceState := SequenceState + 10;
			END_IF
			
		10:	//Started
			Delay(IN:=FALSE);   
			Trace('Starting');

	END_CASE
E_PMLUnitMode.ePMLUnitMode_Maintenance:
;
E_PMLUnitMode.ePMLUnitMode_Manual:
;
			SUPER^.Starting();

END_CASE

]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_Machine">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Machine.CreateEvents">
      <LineId Id="3" Count="4" />
      <LineId Id="9" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Machine.CyclicLogic">
      <LineId Id="3" Count="5" />
      <LineId Id="13" Count="1" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Machine.Execute">
      <LineId Id="23" Count="3" />
      <LineId Id="39" Count="0" />
      <LineId Id="32" Count="3" />
      <LineId Id="27" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="69" Count="0" />
      <LineId Id="64" Count="0" />
      <LineId Id="71" Count="0" />
      <LineId Id="70" Count="0" />
      <LineId Id="43" Count="1" />
      <LineId Id="57" Count="1" />
      <LineId Id="66" Count="0" />
      <LineId Id="59" Count="4" />
      <LineId Id="67" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="68" Count="0" />
      <LineId Id="55" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="53" Count="1" />
    </LineIds>
    <LineIds Name="FB_Machine.HMIPermissions">
      <LineId Id="3" Count="2" />
      <LineId Id="35" Count="0" />
      <LineId Id="6" Count="1" />
      <LineId Id="9" Count="1" />
      <LineId Id="12" Count="11" />
      <LineId Id="34" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Machine.Idle">
      <LineId Id="23" Count="2" />
      <LineId Id="35" Count="0" />
      <LineId Id="44" Count="1" />
      <LineId Id="36" Count="1" />
      <LineId Id="41" Count="2" />
      <LineId Id="27" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="28" Count="1" />
      <LineId Id="32" Count="0" />
      <LineId Id="30" Count="0" />
    </LineIds>
    <LineIds Name="FB_Machine.Initialize">
      <LineId Id="3" Count="55" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Machine.Starting">
      <LineId Id="29" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="39" Count="1" />
      <LineId Id="51" Count="0" />
      <LineId Id="41" Count="8" />
      <LineId Id="34" Count="1" />
      <LineId Id="37" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="27" Count="1" />
    </LineIds>
  </POU>
</TcPlcObject>