<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_Machine" Id="{d5c1a520-7f34-4388-b108-926928c14741}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Machine EXTENDS FB_PackML_BaseModule // IMPLEMENTS I_ControlsProductionRate
VAR
    // Sub Modules
    GantryXY   : FB_GantryXY  := (Name := 'Gantry', LogStateChanges := TRUE);
    SpindleZ   : FB_SpindleZ    := (Name := 'Spindle', LogStateChanges := TRUE);

    // Components
	
    //Initial List of Components
    ipComponents_Init : ARRAY[1..Parameters_PackML_Base.MAX_NO_OF_COMPONENTS] OF I_ComponentBase := [];

    //Alarms for this module
    MachineAlarms : ARRAY[1..MACHINE_ALARM_COUNT] OF FB_TcAlarm;
	

    //Get Data From PackML? Else RecipeManager is running
    DataFromPackML : BOOL := TRUE;

    //Data 
    

    gantrylTimeStart : ULINT;
    gantryTimeEnd   : ULINT;
    gantryTime   : LREAL;

    partTimeStart : ULINT;
    partTimeEnd   : ULINT;
    partTime      : LREAL;
    parts         : DINT;
    product       : DINT;

    //Pack Tags for System
    {attribute 'OPC.UA.DA' := '1'}
    _PackTags : ST_PackMLv30Ext; //ST_PackMLv30 is obsolete in Tc3_PackML_V2
END_VAR

VAR CONSTANT
    //PackTag parameter IDs
    LENGTH         : INT := 1;
    SEALTEMP       : INT := 2;
    SEALTIME       : INT := 3;
    GANTRY_VEL     : INT := 4;
    GANTRY_ACC     : INT := 5;
  //S3ALER_VEL     : INT := 6;
 // S3ALER_ACC     : INT := 7;
    UNWIND_VEL     : INT := 8;
    UNWIND_ACC     : INT := 9;
    OPEN_POS       : INT := 10;
    CLOSED_POS     : INT := 11;

    //Alarm count constant
    MACHINE_ALARM_COUNT : INT := 6;
END_VAR

// Simulation variables
VAR
    EstopInput  : BOOL;
    LowAirInput : BOOL;
    ErrorInput  : BOOL;
    WarnInput   : BOOL;
    InfoInput   : BOOL;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="I_CyclicFB" Id="{c2b7af95-c402-4115-b5e6-e32c5abd7442}" />
    <Folder Name="Methods" Id="{9b31e10f-2f7d-47d0-8b03-ede4de2288d4}">
      <Folder Name="AlarmHandling" Id="{a6320f6e-50c1-47d2-91fb-4b1b67c24593}" />
      <Folder Name="HMI" Id="{2790fade-5dfc-4738-ae5f-b9a7fc939b52}" />
    </Folder>
    <Method Name="CreateEvents" Id="{3ef7297b-dc6e-4a47-8d8e-332da0b8eab2}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD PROTECTED CreateEvents
VAR_INPUT
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Add your event creation here
F_CreateAllEventsInClass(Alarms     := MachineAlarms,
                         ClassSize  := SIZEOF(TC_Events.Seedra),
                         pInitEvent := ADR(TC_EVENTS.Seedra.InitReferenceEvent),
                         Prefix     := Name);

// Super call to base
SUPER^.CreateEvents();]]></ST>
      </Implementation>
    </Method>
    <Method Name="CyclicLogic" Id="{3a2f2751-120e-49d4-84e7-dd5883d6841e}" FolderPath="I_CyclicFB\">
      <Declaration><![CDATA[METHOD CyclicLogic
VAR_INPUT
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT _InitComplete THEN
    _InitComplete := Initialize();
    RETURN;
END_IF

SUPER^.CyclicLogic();

// Fill in the PackTags for the machine output
_PackTags.Status.StateCurrent    := _CurrentState;
_PackTags.Status.UnitModeCurrent := _CurrentMode;


//This is just to simulate some IO for alarms
CyclicLogic_Simulation();]]></ST>
      </Implementation>
    </Method>
    <Method Name="CyclicLogic_Simulation" Id="{71f5236c-9d28-412c-8bd3-07ce42ed551f}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD CyclicLogic_Simulation
VAR_INPUT
END_VAR

VAR_INST
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*	
This is just for testing. Real hardware can be setup in other places
Here the alarms will raise and clear on its own if the input changes	
*)
IF EstopInput AND NOT MachineAlarms[E_Seedra.EmergencyStop].bRaised THEN
    RaiseAlarm2Args(MachineAlarms[E_Seedra.EmergencyStop], '', '');
ELSIF NOT EstopInput AND MachineAlarms[E_Seedra.EmergencyStop].bRaised THEN
    MachineAlarms[E_Seedra.EmergencyStop].Clear(0, 0);
END_IF

IF LowAirInput AND NOT MachineAlarms[E_Seedra.LowAir].bRaised THEN
    RaiseAlarm2Args(MachineAlarms[E_Seedra.LowAir], '', '');
ELSIF NOT LowAirInput AND MachineAlarms[E_Seedra.LowAir].bRaised THEN
    MachineAlarms[E_Seedra.LowAir].Clear(0, 0);
END_IF

//Generic Alarms for Testing
//IF ErrorInput AND NOT MachineAlarms[E_Seedra.AlarmMessage].bRaised THEN
//    RaiseAlarm2Args(MachineAlarms[E_Seedra.AlarmMessage], '', '');
//ELSIF NOT ErrorInput AND MachineAlarms[E_Seedra.AlarmMessage].bRaised THEN
//    MachineAlarms[E_Seedra.AlarmMessage].Clear(0, 0);
//END_IF

//IF WarnInput AND NOT MachineAlarms[E_Seedra.WarnMessage].bRaised THEN
//    RaiseAlarm2Args(MachineAlarms[E_Seedra.WarnMessage], '', '');
//ELSIF NOT WarnInput AND MachineAlarms[E_Seedra.WarnMessage].bRaised THEN
//    MachineAlarms[E_Seedra.WarnMessage].Clear(0, 0);
//END_IF

//IF InfoInput AND NOT MachineAlarms[E_Seedra.InfoMessage].bRaised THEN
//    RaiseAlarm2Args(MachineAlarms[E_Seedra.InfoMessage], '', '');
//ELSIF NOT InfoInput AND MachineAlarms[E_Seedra.InfoMessage].bRaised THEN
//    MachineAlarms[E_Seedra.InfoMessage].Clear(0, 0);
//END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Held" Id="{630272c0-ba2b-083b-3eb9-78a6577810b1}">
      <Declaration><![CDATA[//! @summary This method contains code which will execute when this PackML module is in the <b>Held</b> state
METHOD PROTECTED Held

(*! <description> <b>The base implementation of this method is empty. User must override this method to provide functionality.</b>
<table> 
	<tr>
		<th> Previous State </th>
		<th> Transition In </th>
		<th> Transition Out </th>
		<th> Next State  </th> 
	</tr>
	<tr>
		<td> Holding </td>
		<td> State Complete <i>(Holding)</i></td> 
		<td> Unhold Command </td>
		<td> Unholding </td> 
	</tr>
</table>
This method is called as required by <c>StateControl()</c>
</description> 

*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.Holding();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="HMIPermissions" Id="{01f1aea6-e802-48f8-abd4-50a2a3d31fba}" FolderPath="Methods\HMI\">
      <Declaration><![CDATA[METHOD PROTECTED HMIPermissions
VAR_INPUT
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//General Mode Based Monitoring and handling of HMI control
CASE _CurrentMode OF
    E_PMLUnitMode.ePMLUnitMode_Production:
        CASE _CurrentState OF
            E_PMLState.ePMLState_Stopped:
                AllowHMIControl(ThisModuleOnly := TRUE); //Allow control for recovery
            E_PMLState.ePMLState_Idle:
                //BlockHMIControl();
				     AllowHMIControl(ThisModuleOnly := FALSE); //Allow control for recovery
            E_PMLState.ePMLState_Suspended:
                   AllowHMIControl(ThisModuleOnly := FALSE); //Allow control for recovery
            E_PMLState.ePMLState_Execute:
                 AllowHMIControl(ThisModuleOnly := FALSE); //Allow control for recovery
            E_PMLState.ePMLState_Aborted:
                     AllowHMIControl(ThisModuleOnly := FALSE); //Allow control for recovery
            E_PMLState.ePMLState_Held:
                    AllowHMIControl(ThisModuleOnly := FALSE); //Allow control for recovery
            E_PMLState.ePMLState_Complete:
                BlockHMIControl();
        END_CASE
		
        //AllowHMIControl(ThisModuleOnly := FALSE);
    E_PMLUnitMode.ePMLUnitMode_Manual:
        AllowHMIControl(ThisModuleOnly := FALSE);
    E_PMLUnitMode.ePMLUnitMode_Maintenance:
        AllowHMIControl(ThisModuleOnly := FALSE);
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="HoldImmediate" Id="{84b7ed94-99a4-4ce2-a25d-701c2131ac5b}" FolderPath="Methods\AlarmHandling\">
      <Declaration><![CDATA[METHOD PROTECTED HoldImmediate
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ChangeState(E_PMLCommand.ePMLCommand_Hold);]]></ST>
      </Implementation>
    </Method>
    <Method Name="Holding" Id="{b2b2c62d-c478-06a1-2be5-5c58be64d099}">
      <Declaration><![CDATA[//! @summary This method contains code which will execute when this PackML module is in the <b>Holding</b> state
METHOD PROTECTED Holding
VAR
	i				: UDINT;
	SubModulesReady : BOOL := TRUE;
END_VAR

(*! <description><b>Note:</b> The <i>Hold</i> command is intended to be given by an operator. It is meant to be distinct from a <i>Suspend</i> in that upstream/downstream jams, etc. should be handled automatically using <i>Suspend</i>.  Both <i>Hold</i>and<i>Suspend</i> result in a <i>paused</i> state which should allow resumption of the <b>Execute</b> state. 
<table> 
	<tr>
		<th> Previous State </th>
		<th> Transition In </th>
		<th> Transition Out </th>
		<th> Next State  </th> 
	</tr>
	<tr>
		<td> Execute </td>
		<td> Hold Command </td> 
		<td> State Complete </td>
		<td> Held </td> 
	</tr>
</table>
This method is called as required by <c>StateControl()</c>
</description> 

*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.Holding();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Initialize" Id="{c8e5bfb3-7a5f-4315-8e43-29ab3e5bd8c9}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD PROTECTED Initialize : BOOL
VAR
    i : UDINT; //Generic iteration value
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Initialize := FALSE;
CASE DescendantSequenceState OF
    0:
		RegisterSubmodule(GantryXY);
		RegisterSubmodule(SpindleZ);
		
        _LogModeChanges         := TRUE;
        _LogStateChanges        := TRUE;
        DescendantSequenceState := DescendantSequenceState + 10;
    10:
        //Setup Custom modes here

        (*CustomModes(eMode                          :=,
                    sName                          :=,
                    bDisableClearing               :=,
                    bDisableStarting               :=,
                    bDisableSuspended              :=,
                    bDisableStopping               :=,
                    bDisableAborting               :=,
                    bDisableHolding                :=,
                    bDisableHeld                   :=,
                    bDisableUnholding              :=,
                    bDisableSuspending             :=,
                    bDisableUnsuspending           :=,
                    bDisableResetting              :=,
                    bDisableIdle                   :=,
                    bDisableCompleting             :=,
                    bDisableComplete               :=,
                    bEnableUnitModeChangeStopped   :=,
                    bEnableUnitModeChangeIdle      :=,
                    bEnableUnitModeChangeSuspended :=,
                    bEnableUnitModeChangeExecute   :=,
                    bEnableUnitModeChangeAborted   :=,
                    bEnableUnitModeChangeHeld      :=,
                    bEnableUnitModeChangeComplete  :=,
                    bError                         =>,
                    nErrorId                       =>);*)
        DescendantSequenceState := DescendantSequenceState + 10;
    20:
        //Copy Mode names
        FOR i := 1 TO 3 DO
            ModeNames[i] := F_UnitModeToString(UDINT_TO_DINT(i));
        END_FOR

        DescendantSequenceState := DescendantSequenceState + 10;
    30:
        // Initialize Recipes 

        DescendantSequenceState := DescendantSequenceState + 10;
    40:
        //Call the Super
        IF SUPER^.Initialize() THEN
            DescendantSequenceState := DescendantSequenceState + 10;
        END_IF
    50:
        Initialize := TRUE;
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="RaiseAlarm2Args" Id="{45171f7d-6922-46eb-a058-ee14fb1eff75}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD RaiseAlarm2Args
VAR_IN_OUT
    Alarm : FB_TcAlarm; //Alarm to be raised
END_VAR

VAR_INPUT
    String_1 : STRING; //First String Parameter (The Name of this component will be applied first automatically)
    String_2 : STRING; //Second String Parameter
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[F_RaiseAlarmWithStringParameters(Alarm    := Alarm,
                                 String_1 := Name,
                                 String_2 := String_1,
                                 String_3 := String_2);]]></ST>
      </Implementation>
    </Method>
    <Method Name="SubModuleMonitor" Id="{dcbc78eb-4598-4276-aefb-1642881bb3aa}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD PROTECTED SubModuleMonitor : BOOL
VAR
    AlarmResponses : ARRAY[0..4] OF E_AlarmResponse; //Temporary response array	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Check the sub Modules for Alarm Severity
SUPER^.SubModuleMonitor();

//Check the alarms at the machine level
_CurrentAlarmSeverity := F_GetMaxSeverityRaised(Alarms := MachineAlarms, CurrentSeverity := _CurrentAlarmSeverity);

//Check the severity of the machine level alarms
IF _CurrentState <> E_PMLState.ePMLState_Aborted AND _CurrentState <> E_PMLState.ePMLState_Aborting AND _CurrentState <> E_PMLState.ePMLState_Clearing AND
   _CurrentState <> E_PMLState.ePMLState_Stopped AND _CurrentState <> E_PMLState.ePMLState_Stopping THEN
    AlarmResponses := _ParentFaultResponseDefinitions;
    CASE AlarmResponses[CurrentAlarmSeverity] OF
        E_AlarmResponse.Abort_ImmediateError:
            AbortImmediateError(Name, TRUE);
        E_AlarmResponse.Abort_Immediate:
            AbortImmediate();
        E_AlarmResponse.Stop_Immediate:
            StopImmediate();
        E_AlarmResponse.Stop_Controlled:
            StopControlled();
        E_AlarmResponse.Hold_Immediate:
            HoldImmediate();
        E_AlarmResponse.Suspend_Immediate:
            SuspendImmediate();
        E_AlarmResponse.Suspend_Controlled:
            SuspendControlled();
        E_AlarmResponse.NoResponse:
            ;
    END_CASE
ELSIF _CurrentState = E_PMLState.ePMLState_Stopped OR _CurrentState = E_PMLState.ePMLState_Stopping THEN
    AlarmResponses := _ParentFaultResponseDefinitions;
    CASE AlarmResponses[CurrentAlarmSeverity] OF
        E_AlarmResponse.Abort_ImmediateError:
            AbortImmediateError(Name, TRUE);
        E_AlarmResponse.Abort_Immediate:
            AbortImmediate();
        E_AlarmResponse.NoResponse:
            ;
    END_CASE
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Unholding" Id="{f394e07b-32d0-05db-0f14-0f62ceafed2e}">
      <Declaration><![CDATA[//! @summary This method contains code which will execute when this PackML module is in the <b>Unholding</b> state
METHOD PROTECTED Unholding
VAR
	i				: UDINT;
	SubModulesReady : BOOL := TRUE;
END_VAR

(*! <description><b></b><table> 
	<tr>
		<th> Previous State </th>
		<th> Transition In </th>
		<th> Transition Out </th>
		<th> Next State  </th> 
	</tr>
	<tr>
		<td> Held </td>
		<td> Unhold Command </td> 
		<td> State Complete </td>
		<td> Execute </td> 
	</tr>
</table>
This method is called as required by <c>StateControl()</c>
</description> 

*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.Holding();
]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_Machine">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Machine.CreateEvents">
      <LineId Id="3" Count="6" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Machine.CyclicLogic">
      <LineId Id="3" Count="12" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Machine.CyclicLogic_Simulation">
      <LineId Id="3" Count="32" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Machine.Held">
      <LineId Id="24" Count="0" />
      <LineId Id="23" Count="0" />
    </LineIds>
    <LineIds Name="FB_Machine.HMIPermissions">
      <LineId Id="3" Count="25" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Machine.HoldImmediate">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Machine.Holding">
      <LineId Id="27" Count="1" />
    </LineIds>
    <LineIds Name="FB_Machine.Initialize">
      <LineId Id="3" Count="55" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Machine.RaiseAlarm2Args">
      <LineId Id="3" Count="2" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Machine.SubModuleMonitor">
      <LineId Id="3" Count="37" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Machine.Unholding">
      <LineId Id="51" Count="0" />
      <LineId Id="26" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>